FPJS
----
FPJS is an experimental functional language that compiles to javascript and python. It offers seamless integration with imperative code. It is built using ANTLR 3.

Usage
-----
To compile (and evaluate) a Core program, just supply it's name to the compiler like so:

   python fpjs.py core\examples\fac.cor

Use the command line option -h to obtain more information on available switches.
   
Core
----
      
      NOTE! Large parts of this section have been taken verbatim from it's sources.

The core language is a minimal functional language carefully chosen so that it is possible to translate programs in a rich functional language (such as Miranda) into the Core language without losing expressiveness or efficiency. The Core language thus serves as a clean interface between the 'front end' of the compiler, which is concerned with high-level language constructs, and the 'back end', which is concerned with implementing the Core language in various different ways.

Here is an example Core program, which evaluates to 42:
   
   main = double 21
   double x = x + x

A Core program consists of a set of supercombinator definitions, including a distinguished one, main. To execute the program, we evaluate main. Supercombinators can define functions, such as the definition of double. Supercombinators can have local definitions, using the let construct of the Core language:
   
   main = quadruple 20;
   quadruple x = let twice_x = x+x in twice_x + twice_x

Here twice_x is defined locally within the body of quadruple to be x+x, and quadruple returns twice_x + twice_x. A let expression is non-recursive. For recursive definitions, the Core language uses the letrec construct, which is exactly like let except that its definitions can be recursive. For example:
   
   infinite n = letrec ns = cons n ns in ns

The reason that we distinguish let from letrec in the Core language (rather than providing only letrec) is that let is a bit simpler to implement than letrec, and we may get slightly better code. The left-hand side of a let or letrec binding must always be a simple variable.

It is sometimes convenient to be able to denote functions using explicit lambda abstractions, and the Core language provides a construct to do so. For example, in the program

   double_list xs = map (\x. 2*x) xs

the lambda abstraction (\x. 2*x) denotes the function which doubles its argument.

A universal feature of all modern functional programming languages is the provision of structured types, often called algebraic data types. The Core language provides a single family of constructors:
   
   Pack{tag, arity}

Here, tag is an integer which uniquely identifies the constructor, and arity tells how many arguments it takes. So in the Core language one writes:

   Pack{2,2} (Pack{1,1} 3) (Pack{1,1} 4)

instead of:

   Branch (Leaf 3) (Leaf 4)

The tag is required so that objects built with different constructors can be distinguished from one another. In a well-typed program, objects of different type will never need to be 
distinguished at run-time, so tags only need to be unique within a data type. Hence, we can start the tag at 1 afresh for each new data type.

In general, the pattern matching allowed by modern functional programming languages can be rather complex, with multiple nested patterns, overlapping patterns, guards and so on. For 
the Core language, we eliminate these complications by outlawing all complex forms of pattern matching! We do this by providing only case expressions in the Core language.  

The important thing about case expressions is that each alternative consists only of a tag followed by a number of variables (which should be the same as the arity of the constructor). No nested patterns are allowed. Case 
expressions have a very simple operational interpretation, rather like a multi-way jump: evaluate the expression to be analysed, get the tag of the constructor it is built with and evaluate the appropriate alternative.

   precedence | associativity | operator
   -------------------------------------
       6      | left          | application
       5      | left          | /, *  
       4      | left          | +, -
       3      | left          | <, <=, ==, !=, >=, >
       2      | left          | &
       1      | left          | |

Basic programs
--------------
The programs in this section require only integer constants and function application. This program should return the value 3 rather quickly!
   
   main = I 3

The next program requires a couple more steps before returning 3.
   
   id = S K K;
   main = id 3

This one makes quite a few applications of id (how many? (ans: 687)).

   id = S K K;
   main = twice twice twice id 3

This program should show up the difference between a system which does updating and one which does not. If updating occurs, the evaluation of (I I I) should take place only once; without updating it will take place twice.

   main = twice (I I I) 3

This example uses a functional representation of lists (see Section 2.8.3) to build an infinite list of 4's, and then takes its second element. The functions for head and tail (hd and tl) return abort if their argument is an empty list. The abort supercombinator just generates an infinite loop.

   cons a b cc cn = cc a b;
   nil cc cn = cn;
   hd list = list K abort;
   tl list = list K1 abort;
   abort = abort;

   infinite x = cons x (infinite x);
   main = hd (tl (infinite 4))

If updating is implemented, then this program will execute in fewer steps than if not, because the evaluation of id1 is shared.
   
   main = let id1 = I I I in id1 id1 3

We should test nested let expressions too:

   oct g x = let h = twice g in let k = twice h in k (k x);
   main = oct I 4

The next program tests letrecs, using 'functional lists' based on the earlier definitions of cons, nil, etc.
   
   infinite x = letrec xs = cons x xs in xs;
   main = hd (tl (tl (infinite 4)))

We begin with simple tests which do not require the conditional.
   
   main = 4*5+(2-5)

This next program needs function calls to work properly. Try replacing twice twice with twice twice twice or twice twice twice twice. Predict what the result should be.
   
   inc x = x+1;
   main = twice twice inc 4

Using functional lists again, we can write a length function:

   length xs = xs length1 0;
   length1 x xs = 1 + (length xs);
   main = length (cons 3 (cons 3 (cons 3 nil)))

Once we have conditionals we can at last write 'interesting' programs. For example, factorial:
   
   fac n = if (n==0) 1 (n * fac (n-1)) ;
   main = fac 5

The next program computes the greatest common divisor of two integers, using Euclid's algorithm:
   
   gcd a b = if (a==b) a if (a<b) (gcd b a) (gcd b (a-b));
   main = gcd 6 10

The nfib function is interesting because its result (an integer) gives a count of how many function calls were made during its execution. So the result divided by the execution time gives a performance measure in function calls per second. As a result, nfib is quite widely used as a benchmark. The 'nfib-number' for a particular implementation needs to be taken with an enormous dose of salt, however, because it is critically dependent on various rather specialised optimisations.
   
   nfib n = if (n==0) 1 (1 + nfib (n-1) + nfib (n-2));
   main = nfib 4

This program returns a list of descending integers. The evaluator should be expecting a list as the result of the program. cons and nil are now expected to be implemented in the prelude as Pack{2,2} and Pack{1,0} respectively.
   
   downfrom n = if (n == 0) nil (cons n (downfrom (n-1)));
   main = downfrom 4

The next program implements the Sieve of Eratosthenes to generate the infinite list of primes, and takes the first few elements of the result list. If you arrange that output is printed incrementally, as it is generated, you can remove the call to take and just print the infinite list.
   
   main = take 3 (sieve (from 2)) ;
   from n = cons n (from (n+1)) ;
   sieve xs = case xs of
      <1> -> nil;
      <2> p ps -> cons p (sieve (filter (nonMultiple p) ps));
   
   filter predicate xs = case xs of
         <1> -> nil;
         <2> p ps -> let rest = filter predicate ps
      in
         if (predicate p) (cons p rest) rest;

   nonMultiple p n = ((n/p)*p) != n ;
   take n xs = if (n==0) nil (case xs of
      <1> -> nil;
      <2> p ps -> cons p (take (n-1) ps))

Sources
-------
[1]: Implementing Functional Languages: a tutorial by Simon L. Peyton Jones & David R. Lester (a copy is available in etc/)